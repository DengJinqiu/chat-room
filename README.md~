## Weclome to chat-room

### [It is deployed here](http://jd-chat-room.herokuapp.com/), feel free to create a user name and chat, enjoy :)

####
1. The server is implimented by Ruby on Rails 5. The websocket connection is implimented by [Action Cable](https://github.com/rails/actioncable)
2. A unique id is generated by the server when a client connects and logins, and this id is saved in this client's cookie, which is used for further authorization.
3. Each message has three fields, conversation id, context, timestamp. The conversation id is a one to one mapping to the user names in this conversation.
4. A websocket connection between client and server is created after login. There are two channels in this connection.
⋅⋅1. User change channel: all clients listen to this channel, when a new user is created, the server broadcast this new user name on this channel.
⋅⋅2. New message channel: the channel id is the same as conversation id. When a new message added to one conversation, add this message to db and broadcast it on the corresponding message channel.
5. Ajax is used to avoid refreshing the whole page, when fetch previous message and display new message.

#### follow up question
Here is a chart for scaling the system
![alt text][chart]
[chart]: https://docs.google.com/drawings/d/1s1dk5f8mdFE8POHewcBrZBLRyZRuugrwmeAyg979-NE/pub?w=1459&h=883 "chart"
1. All conversations need to be up to date at all times.
* Broadcast any new message to all app servers having this conversation and deliver to client through web-socket.
2. Consider the case where a device is offline for a day and comes back online.
* First get all the conversations need to be updated. Since all the new messages will be cached on caching server, it is fast to fetch recent missing messages. For the old messages no longer in the caching server, need to get it from db, and these kind of data should have a lower priority to cache again.
3. Also consider the possibility of a user having multiple devices.
* This problem is illustrated in the chart.
4. What if a user has had a total of ~1'000 conversations and goes online/offline frequently?
* If the user goes online/offine frequently, it means, we only need to update the recent missing messages which are cached on the caching server or it has a high possbility that it is still cached on the app server. Fetching those data is fast.
